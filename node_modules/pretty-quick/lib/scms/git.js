"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stageFile = exports.getUnstagedChangedFiles = exports.getChangedFiles = exports.getSinceRevision = exports.detect = exports.name = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const find_up_1 = tslib_1.__importDefault(require("find-up"));
const tinyexec_1 = require("tinyexec");
exports.name = 'git';
const detect = (directory) => {
    if (fs_1.default.existsSync(path_1.default.join(directory, '.git'))) {
        return directory;
    }
    const gitDirectory = find_up_1.default.sync('.git', {
        cwd: directory,
        type: 'directory',
    });
    const gitWorkTreeFile = find_up_1.default.sync('.git', {
        cwd: directory,
        type: 'file',
    });
    if (!gitDirectory && !gitWorkTreeFile) {
        return null;
    }
    if (gitDirectory && !gitWorkTreeFile) {
        return path_1.default.dirname(gitDirectory);
    }
    if (gitWorkTreeFile && !gitDirectory) {
        return path_1.default.dirname(gitWorkTreeFile);
    }
    const gitRepoDirectory = path_1.default.dirname(gitDirectory);
    const gitWorkTreeDirectory = path_1.default.dirname(gitWorkTreeFile);
    return gitRepoDirectory.length > gitWorkTreeDirectory.length
        ? gitRepoDirectory
        : gitWorkTreeDirectory;
};
exports.detect = detect;
const runGit = (directory, args) => (0, tinyexec_1.exec)('git', args, {
    nodeOptions: {
        cwd: directory,
    },
});
const getLines = (tinyexecOutput) => tinyexecOutput.stdout.split('\n');
const getSinceRevision = async (directory, { staged, branch }) => {
    try {
        let revision = 'HEAD';
        if (!staged) {
            const revisionOutput = await runGit(directory, [
                'merge-base',
                'HEAD',
                branch || 'master',
            ]);
            revision = revisionOutput.stdout.trim();
        }
        const revParseOutput = await runGit(directory, [
            'rev-parse',
            '--short',
            revision,
        ]);
        return revParseOutput.stdout.trim();
    }
    catch (err) {
        const error = err;
        if (/HEAD/.test(error.message) ||
            (staged && /Needed a single revision/.test(error.message))) {
            return null;
        }
        throw error;
    }
};
exports.getSinceRevision = getSinceRevision;
const getChangedFiles = async (directory, revision, staged) => [
    ...getLines(await runGit(directory, [
        'diff',
        '--name-only',
        staged ? '--cached' : null,
        '--diff-filter=ACMRTUB',
        revision,
    ].filter(Boolean))),
    ...(staged
        ? []
        : getLines(await runGit(directory, [
            'ls-files',
            '--others',
            '--exclude-standard',
        ]))),
].filter(Boolean);
exports.getChangedFiles = getChangedFiles;
const getUnstagedChangedFiles = (directory) => {
    return (0, exports.getChangedFiles)(directory, null, false);
};
exports.getUnstagedChangedFiles = getUnstagedChangedFiles;
const stageFile = (directory, file) => runGit(directory, ['add', file]);
exports.stageFile = stageFile;
//# sourceMappingURL=git.js.map