/* tslint:disable */
/* eslint-disable */
/**
 * Invox API
 * Open API documentation for Invox project
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosInstance, AxiosPromise } from 'axios';
import { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, createRequestFunction, serializeDataIfNeeded, setBearerAuthToObject, setSearchParams, toPathString } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, RequestArgs, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AWSHeadObjectNotFoundError
 */
export interface AWSHeadObjectNotFoundError {
  /**
   * 
   * @type {string}
   * @memberof AWSHeadObjectNotFoundError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof AWSHeadObjectNotFoundError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof AWSHeadObjectNotFoundError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface AuthNotActiveError
 */
export interface AuthNotActiveError {
  /**
   * 
   * @type {string}
   * @memberof AuthNotActiveError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof AuthNotActiveError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof AuthNotActiveError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface AuthNotFoundError
 */
export interface AuthNotFoundError {
  /**
   * 
   * @type {string}
   * @memberof AuthNotFoundError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof AuthNotFoundError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof AuthNotFoundError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
  /**
   * 
   * @type {string}
   * @memberof BadRequestError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof BadRequestError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof BadRequestError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface CannotDeactivateDeactivatedUserError
 */
export interface CannotDeactivateDeactivatedUserError {
  /**
   * 
   * @type {string}
   * @memberof CannotDeactivateDeactivatedUserError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CannotDeactivateDeactivatedUserError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CannotDeactivateDeactivatedUserError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface CannotDeactivateInactiveUserError
 */
export interface CannotDeactivateInactiveUserError {
  /**
   * 
   * @type {string}
   * @memberof CannotDeactivateInactiveUserError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CannotDeactivateInactiveUserError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CannotDeactivateInactiveUserError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface CannotDeactivateInvitedUserError
 */
export interface CannotDeactivateInvitedUserError {
  /**
   * 
   * @type {string}
   * @memberof CannotDeactivateInvitedUserError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CannotDeactivateInvitedUserError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CannotDeactivateInvitedUserError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface CannotDeactivateRequestedUserError
 */
export interface CannotDeactivateRequestedUserError {
  /**
   * 
   * @type {string}
   * @memberof CannotDeactivateRequestedUserError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CannotDeactivateRequestedUserError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CannotDeactivateRequestedUserError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface CannotReactivateActiveUserError
 */
export interface CannotReactivateActiveUserError {
  /**
   * 
   * @type {string}
   * @memberof CannotReactivateActiveUserError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CannotReactivateActiveUserError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CannotReactivateActiveUserError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface CannotReactivateInactiveUserError
 */
export interface CannotReactivateInactiveUserError {
  /**
   * 
   * @type {string}
   * @memberof CannotReactivateInactiveUserError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CannotReactivateInactiveUserError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CannotReactivateInactiveUserError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface CannotReactivateInvitedUserError
 */
export interface CannotReactivateInvitedUserError {
  /**
   * 
   * @type {string}
   * @memberof CannotReactivateInvitedUserError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CannotReactivateInvitedUserError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CannotReactivateInvitedUserError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface CannotReactivateRequestedUserError
 */
export interface CannotReactivateRequestedUserError {
  /**
   * 
   * @type {string}
   * @memberof CannotReactivateRequestedUserError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CannotReactivateRequestedUserError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CannotReactivateRequestedUserError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
  /**
   * 
   * @type {string}
   * @memberof ChangePasswordDto
   */
  oldPassword: string;
  /**
   * 
   * @type {string}
   * @memberof ChangePasswordDto
   */
  newPassword: string;
}
/**
 * 
 * @export
 * @interface CountiesCreateResponse
 */
export interface CountiesCreateResponse {
  /**
   * 
   * @type {string}
   * @memberof CountiesCreateResponse
   */
  id: string;
}
/**
 * 
 * @export
 * @interface CountyCreateDto
 */
export interface CountyCreateDto {
  /**
   * 
   * @type {string}
   * @memberof CountyCreateDto
   */
  name: string;
  /**
   * 
   * @type {string}
   * @memberof CountyCreateDto
   */
  fipsCode: string;
  /**
   * 
   * @type {string}
   * @memberof CountyCreateDto
   */
  stateId: string;
  /**
   * 
   * @type {number}
   * @memberof CountyCreateDto
   */
  order: number;
}
/**
 * 
 * @export
 * @interface CreateRoleDto
 */
export interface CreateRoleDto {
  /**
   * 
   * @type {string}
   * @memberof CreateRoleDto
   */
  name: string;
}
/**
 * 
 * @export
 * @interface CreateRoleResponse
 */
export interface CreateRoleResponse {
  /**
   * 
   * @type {string}
   * @memberof CreateRoleResponse
   */
  id: string;
}
/**
 * 
 * @export
 * @interface CronJobLockSetupError
 */
export interface CronJobLockSetupError {
  /**
   * 
   * @type {string}
   * @memberof CronJobLockSetupError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof CronJobLockSetupError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof CronJobLockSetupError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ErrorType {
  UserNotFound = 'UserNotFound',
  AuthNotFound = 'AuthNotFound',
  RoleNotFound = 'RoleNotFound',
  InvalidRoleForUserTypeError = 'InvalidRoleForUserTypeError',
  NoAccessError = 'NoAccessError',
  InvalidLenderError = 'InvalidLenderError',
  FailedToGetResource = 'FailedToGetResource',
  FailedToSaveResource = 'FailedToSaveResource',
  AddressNotFound = 'AddressNotFound',
  SystemAdminUserExists = 'SystemAdminUserExists',
  LimitExceedBulkCustomersUpdate = 'LimitExceedBulkCustomersUpdate',
  UserDoesNotHavePrivileges = 'UserDoesNotHavePrivileges',
  BadRequest = 'BadRequest',
  InvalidPassword = 'InvalidPassword',
  UserExistsWithEmail = 'UserExistsWithEmail',
  PasswordTokenNotFound = 'PasswordTokenNotFound',
  PasswordTokenExpired = 'PasswordTokenExpired',
  WrongPassword = 'WrongPassword',
  SameAsOneOfPreviousPasswords = 'SameAsOneOfPreviousPasswords',
  PermissionsRequired = 'PermissionsRequired',
  InvalidPermissionName = 'InvalidPermissionName',
  InvalidPermissionForUserType = 'InvalidPermissionForUserType',
  UserNotActive = 'UserNotActive',
  AuthNotActive = 'AuthNotActive',
  RoleNotActive = 'RoleNotActive',
  RefreshTokenExpiredOrNotActive = 'RefreshTokenExpiredOrNotActive',
  UserIsNotEligibleForInvitation = 'UserIsNotEligibleForInvitation',
  CannotDeactivateInvitedUser = 'CannotDeactivateInvitedUser',
  CannotDeactivateDeactivatedUser = 'CannotDeactivateDeactivatedUser',
  CannotDeactivateInactiveUser = 'CannotDeactivateInactiveUser',
  CannotDeactivateRequestedUser = 'CannotDeactivateRequestedUser',
  Forbidden = 'Forbidden',
  Unauthorized = 'Unauthorized',
  RefreshTokenBlocked = 'RefreshTokenBlocked',
  InvalidEmail = 'InvalidEmail',
  InvalidInt = 'InvalidInt',
  InvalidDecimal = 'InvalidDecimal',
  InvalidNumber = 'InvalidNumber',
  MinNumber = 'MinNumber',
  MaxNumber = 'MaxNumber',
  NotMatchingRegex = 'NotMatchingRegex',
  NotOneOfValues = 'NotOneOfValues',
  InvalidDate = 'InvalidDate',
  InvalidString = 'InvalidString',
  InvalidBool = 'InvalidBool',
  InvalidValue = 'InvalidValue',
  MinStringLength = 'MinStringLength',
  MaxStringLength = 'MaxStringLength',
  MediaFileNotFound = 'MediaFileNotFound',
  MediaFileInvalid = 'MediaFileInvalid',
  FileTypeNotSupported = 'FileTypeNotSupported',
  MediaFileTypeMetaDataNotFound = 'MediaFileTypeMetaDataNotFound',
  MediaFileFailedToProcess = 'MediaFileFailedToProcess',
  InternalServerError = 'InternalServerError',
  AwsHeadObjectNotFoundError = 'AWSHeadObjectNotFoundError',
  InvalidEnumValidationError = 'InvalidEnumValidationError',
  AwsObjectNotFoundError = 'AWSObjectNotFoundError',
  ServiceError = 'ServiceError',
  InvalidDateRangeError = 'InvalidDateRangeError',
  CronJobLockSetUpError = 'CronJobLockSetUpError',
  InvalidPhoneNumberError = 'InvalidPhoneNumberError',
  UserNotSystemAdmin = 'UserNotSystemAdmin',
  CannotReactivateInvitedUserError = 'CannotReactivateInvitedUserError',
  CannotReactivateActiveUserError = 'CannotReactivateActiveUserError',
  CannotReactivateRequestedUserError = 'CannotReactivateRequestedUserError',
  StateNotFound = 'StateNotFound',
  StateExist = 'StateExist',
  CountyNotFound = 'CountyNotFound',
  CountyExist = 'CountyExist',
  MunicipalityNotFound = 'MunicipalityNotFound',
  MunicipalityExist = 'MunicipalityExist',
  SpecialDistrictsNotFound = 'SpecialDistrictsNotFound',
  SpecialDistrictsExist = 'SpecialDistrictsExist',
  AwsCloudFrontError = 'AWSCloudFrontError',
  FileNotFoundError = 'FileNotFoundError',
  AwsUploadFileError = 'AWSUploadFileError',
  ParcelReferenceExistError = 'ParcelReferenceExistError',
  InvalidStateIdError = 'InvalidStateIdError',
  DuplicateParcelKeyError = 'DuplicateParcelKeyError',
  InvalidFipsCodesError = 'InvalidFipsCodesError',
  InvalidExceptionFixError = 'InvalidExceptionFixError',
  InvalidPreviousInfoIdError = 'InvalidPreviousInfoIdError'
}

/**
 * 
 * @export
 * @interface FailedToGetResourceError
 */
export interface FailedToGetResourceError {
  /**
   * 
   * @type {string}
   * @memberof FailedToGetResourceError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof FailedToGetResourceError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof FailedToGetResourceError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface FailedToSaveResourceError
 */
export interface FailedToSaveResourceError {
  /**
   * 
   * @type {string}
   * @memberof FailedToSaveResourceError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof FailedToSaveResourceError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof FailedToSaveResourceError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface FileTypeNotSupportedError
 */
export interface FileTypeNotSupportedError {
  /**
   * 
   * @type {string}
   * @memberof FileTypeNotSupportedError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof FileTypeNotSupportedError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof FileTypeNotSupportedError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
  /**
   * 
   * @type {string}
   * @memberof ForbiddenError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof ForbiddenError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof ForbiddenError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface ForgotPasswordDto
 */
export interface ForgotPasswordDto {
  /**
   * 
   * @type {string}
   * @memberof ForgotPasswordDto
   */
  email: string;
}
/**
 * 
 * @export
 * @interface GetFileResponse
 */
export interface GetFileResponse {
  /**
   * 
   * @type {string}
   * @memberof GetFileResponse
   */
  id: string;
  /**
   * 
   * @type {string}
   * @memberof GetFileResponse
   */
  url: string;
}
/**
 * 
 * @export
 * @interface GetFileUploadResponse
 */
export interface GetFileUploadResponse {
  /**
   * 
   * @type {string}
   * @memberof GetFileUploadResponse
   */
  id: string;
  /**
   * 
   * @type {string}
   * @memberof GetFileUploadResponse
   */
  key: string;
  /**
   * 
   * @type {string}
   * @memberof GetFileUploadResponse
   */
  name: string;
  /**
   * 
   * @type {string}
   * @memberof GetFileUploadResponse
   */
  extension: string;
  /**
   * 
   * @type {string}
   * @memberof GetFileUploadResponse
   */
  mimeType: string;
  /**
   * 
   * @type {number}
   * @memberof GetFileUploadResponse
   */
  size: number;
  /**
   * 
   * @type {string}
   * @memberof GetFileUploadResponse
   */
  url: string | null;
  /**
   * 
   * @type {string}
   * @memberof GetFileUploadResponse
   */
  type: string;
}
/**
 * 
 * @export
 * @interface GetRoleListData
 */
export interface GetRoleListData {
  /**
   * 
   * @type {string}
   * @memberof GetRoleListData
   */
  id: string;
  /**
   * 
   * @type {string}
   * @memberof GetRoleListData
   */
  name: string;
  /**
   * 
   * @type {boolean}
   * @memberof GetRoleListData
   */
  status: boolean;
}
/**
 * 
 * @export
 * @interface GetRoleListResponse
 */
export interface GetRoleListResponse {
  /**
   * 
   * @type {Array<GetRoleListData>}
   * @memberof GetRoleListResponse
   */
  data: Array<GetRoleListData>;
  /**
   * 
   * @type {number}
   * @memberof GetRoleListResponse
   */
  total: number;
}
/**
 * 
 * @export
 * @interface GetStatesResponse
 */
export interface GetStatesResponse {
  /**
   * 
   * @type {string}
   * @memberof GetStatesResponse
   */
  id: string;
  /**
   * 
   * @type {string}
   * @memberof GetStatesResponse
   */
  name: string;
  /**
   * 
   * @type {object}
   * @memberof GetStatesResponse
   */
  totalCounties: object;
  /**
   * 
   * @type {object}
   * @memberof GetStatesResponse
   */
  totalSpecialDistricts: object;
  /**
   * 
   * @type {Array<object>}
   * @memberof GetStatesResponse
   */
  counties?: Array<object>;
  /**
   * 
   * @type {Array<object>}
   * @memberof GetStatesResponse
   */
  specialDistricts?: Array<object>;
}
/**
 * 
 * @export
 * @interface GetUserListResponse
 */
export interface GetUserListResponse {
  /**
   * 
   * @type {Array<GetUserResponse>}
   * @memberof GetUserListResponse
   */
  data: Array<GetUserResponse>;
  /**
   * 
   * @type {number}
   * @memberof GetUserListResponse
   */
  total: number;
}
/**
 * 
 * @export
 * @interface GetUserResponse
 */
export interface GetUserResponse {
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  id: string;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  firstName: string;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  lastName: string;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  email: string;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  countryCode: string | null;
  /**
   * 
   * @type {number}
   * @memberof GetUserResponse
   */
  phoneNumber: number | null;
  /**
   * 
   * @type {boolean}
   * @memberof GetUserResponse
   */
  status: boolean | null;
  /**
   * 
   * @type {boolean}
   * @memberof GetUserResponse
   */
  isReadOnly: boolean;
  /**
   * 
   * @type {boolean}
   * @memberof GetUserResponse
   */
  isPrimary: boolean;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  userType: string;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  createdBy: string | null;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  profilePictureId: string | null;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  updatedBy: string | null;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  deletedBy: string | null;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  createdAt: string | null;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  updatedAt: string | null;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  deletedAt: string | null;
  /**
   * 
   * @type {string}
   * @memberof GetUserResponse
   */
  lastLoginAt: string | null;
  /**
   * 
   * @type {GetFileResponse}
   * @memberof GetUserResponse
   */
  profilePicture: GetFileResponse | null;
}
/**
 * 
 * @export
 * @interface GetInvoiceResponse
 */
export interface GetInvoiceResponse {
  /**
   *
   * @type {string}
   * @memberof GetUserResponse
   */
  id: string;
  /**
   *
   * @type {boolean}
   * @memberof GetInvoiceResponse
   */
  checkbox?: boolean;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  fileName: string;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  location: string;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  source: string;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  receivedon: string;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  dueon: string;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  processedon: string;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  reviewedby: string;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  filedetails: string;
  /**
   *
   * @type {string}
   * @memberof GetInvoiceResponse
   */
  status: string;
}

/**
 *
 * @export
 * @interface GetLogResponse
 */
export interface GetLogResponse {
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  id: string;

  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  firstName: string;

  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  lastName: string;

  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  role: {
    id: string;
    name: string;
  };
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  timestamp: string;
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  actionType: string;
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  host: string;
  /**
  *
  * @type {string}
  * @memberof GetLogResponse
  */
  securityLevel: string;
  /**
   *
   * @type {string}
   * @memberof GetLogResponse
   */
  source: string;
}

/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
  /**
   * 
   * @type {number}
   * @memberof InlineResponse400
   */
  status?: number;
  /**
   * 
   * @type {string}
   * @memberof InlineResponse400
   */
  message?: string;
  /**
   * 
   * @type {Array<InternalServerError | ForbiddenError | UnauthorizedError>}
   * @memberof InlineResponse400
   */
  errors?: Array<InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
  /**
   * 
   * @type {number}
   * @memberof InlineResponse4001
   */
  status?: number;
  /**
   * 
   * @type {string}
   * @memberof InlineResponse4001
   */
  message?: string;
  /**
   * 
   * @type {Array<InternalServerError>}
   * @memberof InlineResponse4001
   */
  errors?: Array<InternalServerError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4002
 */
export interface InlineResponse4002 {
  /**
   * 
   * @type {number}
   * @memberof InlineResponse4002
   */
  status?: number;
  /**
   * 
   * @type {string}
   * @memberof InlineResponse4002
   */
  message?: string;
  /**
   * 
   * @type {Array<AuthNotFoundError | WrongPasswordError | SameAsOneOfPreviousPasswordsError | InternalServerError | ForbiddenError | UnauthorizedError>}
   * @memberof InlineResponse4002
   */
  errors?: Array<AuthNotFoundError | WrongPasswordError | SameAsOneOfPreviousPasswordsError | InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
  /**
   * 
   * @type {string}
   * @memberof InternalServerError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InternalServerError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InternalServerError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidBoolValidationError
 */
export interface InvalidBoolValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidBoolValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidBoolValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidBoolValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidDateValidationError
 */
export interface InvalidDateValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidDateValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidDateValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidDateValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidDecimalValidationError
 */
export interface InvalidDecimalValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidDecimalValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidDecimalValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidDecimalValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidEmailValidationError
 */
export interface InvalidEmailValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidEmailValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidEmailValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidEmailValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidEnumValidationError
 */
export interface InvalidEnumValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidEnumValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidEnumValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidEnumValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidIntValidationError
 */
export interface InvalidIntValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidIntValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidIntValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidIntValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidLenderError
 */
export interface InvalidLenderError {
  /**
   * 
   * @type {string}
   * @memberof InvalidLenderError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidLenderError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidLenderError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidNumberValidationError
 */
export interface InvalidNumberValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidNumberValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidNumberValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidNumberValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidPasswordError
 */
export interface InvalidPasswordError {
  /**
   * 
   * @type {string}
   * @memberof InvalidPasswordError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidPasswordError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidPasswordError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidPermissionNameError
 */
export interface InvalidPermissionNameError {
  /**
   * 
   * @type {string}
   * @memberof InvalidPermissionNameError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidPermissionNameError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidPermissionNameError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidPhoneNumberError
 */
export interface InvalidPhoneNumberError {
  /**
   * 
   * @type {string}
   * @memberof InvalidPhoneNumberError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidPhoneNumberError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidPhoneNumberError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidRoleForUserTypeError
 */
export interface InvalidRoleForUserTypeError {
  /**
   * 
   * @type {string}
   * @memberof InvalidRoleForUserTypeError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidRoleForUserTypeError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidRoleForUserTypeError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidStringValidationError
 */
export interface InvalidStringValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidStringValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidStringValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidStringValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface InvalidValueValidationError
 */
export interface InvalidValueValidationError {
  /**
   * 
   * @type {string}
   * @memberof InvalidValueValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof InvalidValueValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof InvalidValueValidationError
   */
  errorStack: object;
}

/**
 * 
 * @export
 * @interface MaxNumberValidationError
 */
export interface MaxNumberValidationError {
  /**
   * 
   * @type {string}
   * @memberof MaxNumberValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof MaxNumberValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof MaxNumberValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface MaxStringLengthValidationError
 */
export interface MaxStringLengthValidationError {
  /**
   * 
   * @type {string}
   * @memberof MaxStringLengthValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof MaxStringLengthValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof MaxStringLengthValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface MediaFileInvalidError
 */
export interface MediaFileInvalidError {
  /**
   * 
   * @type {string}
   * @memberof MediaFileInvalidError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof MediaFileInvalidError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof MediaFileInvalidError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface MediaFileTypeMetaDataNotFoundError
 */
export interface MediaFileTypeMetaDataNotFoundError {
  /**
   * 
   * @type {string}
   * @memberof MediaFileTypeMetaDataNotFoundError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof MediaFileTypeMetaDataNotFoundError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof MediaFileTypeMetaDataNotFoundError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface MinNumberValidationError
 */
export interface MinNumberValidationError {
  /**
   * 
   * @type {string}
   * @memberof MinNumberValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof MinNumberValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof MinNumberValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface MinStringLengthValidationError
 */
export interface MinStringLengthValidationError {
  /**
   * 
   * @type {string}
   * @memberof MinStringLengthValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof MinStringLengthValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof MinStringLengthValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface MunicipalitiesCreateDto
 */
export interface MunicipalitiesCreateDto {
  /**
   * 
   * @type {string}
   * @memberof MunicipalitiesCreateDto
   */
  name: string;
  /**
   * 
   * @type {string}
   * @memberof MunicipalitiesCreateDto
   */
  fipsCode: string;
  /**
   * 
   * @type {string}
   * @memberof MunicipalitiesCreateDto
   */
  countyId: string;
  /**
   * 
   * @type {number}
   * @memberof MunicipalitiesCreateDto
   */
  order: number;
}
/**
 * 
 * @export
 * @interface MunicipalitiesCreateResponse
 */
export interface MunicipalitiesCreateResponse {
  /**
   * 
   * @type {string}
   * @memberof MunicipalitiesCreateResponse
   */
  id: string;
}
/**
 * 
 * @export
 * @interface NoAccessError
 */
export interface NoAccessError {
  /**
   * 
   * @type {string}
   * @memberof NoAccessError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof NoAccessError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof NoAccessError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface NotMatchingRegexValidationError
 */
export interface NotMatchingRegexValidationError {
  /**
   * 
   * @type {string}
   * @memberof NotMatchingRegexValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof NotMatchingRegexValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof NotMatchingRegexValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface NotOneOfValuesValidationError
 */
export interface NotOneOfValuesValidationError {
  /**
   * 
   * @type {string}
   * @memberof NotOneOfValuesValidationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof NotOneOfValuesValidationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof NotOneOfValuesValidationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface PasswordTokenExpiredError
 */
export interface PasswordTokenExpiredError {
  /**
   * 
   * @type {string}
   * @memberof PasswordTokenExpiredError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof PasswordTokenExpiredError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof PasswordTokenExpiredError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface PasswordTokenNotFoundError
 */
export interface PasswordTokenNotFoundError {
  /**
   * 
   * @type {string}
   * @memberof PasswordTokenNotFoundError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof PasswordTokenNotFoundError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof PasswordTokenNotFoundError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface PermissionsRequiredError
 */
export interface PermissionsRequiredError {
  /**
   * 
   * @type {string}
   * @memberof PermissionsRequiredError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof PermissionsRequiredError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof PermissionsRequiredError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface RefreshTokenBlockedError
 */
export interface RefreshTokenBlockedError {
  /**
   * 
   * @type {string}
   * @memberof RefreshTokenBlockedError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof RefreshTokenBlockedError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof RefreshTokenBlockedError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
  /**
   * 
   * @type {string}
   * @memberof RefreshTokenDto
   */
  refreshToken: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenExpiredOrNotActiveError
 */
export interface RefreshTokenExpiredOrNotActiveError {
  /**
   * 
   * @type {string}
   * @memberof RefreshTokenExpiredOrNotActiveError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof RefreshTokenExpiredOrNotActiveError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof RefreshTokenExpiredOrNotActiveError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface RoleNotActiveError
 */
export interface RoleNotActiveError {
  /**
   * 
   * @type {string}
   * @memberof RoleNotActiveError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof RoleNotActiveError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof RoleNotActiveError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface RoleNotFoundError
 */
export interface RoleNotFoundError {
  /**
   * 
   * @type {string}
   * @memberof RoleNotFoundError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof RoleNotFoundError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof RoleNotFoundError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface SameAsOneOfPreviousPasswordsError
 */
export interface SameAsOneOfPreviousPasswordsError {
  /**
   * 
   * @type {string}
   * @memberof SameAsOneOfPreviousPasswordsError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof SameAsOneOfPreviousPasswordsError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof SameAsOneOfPreviousPasswordsError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface ServiceError
 */
export interface ServiceError {
  /**
   * 
   * @type {string}
   * @memberof ServiceError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof ServiceError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof ServiceError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface SetUserPasswordDto
 */
export interface SetUserPasswordDto {
  /**
   * 
   * @type {string}
   * @memberof SetUserPasswordDto
   */
  userId: string;
  /**
   * 
   * @type {string}
   * @memberof SetUserPasswordDto
   */
  token: string;
  /**
   * 
   * @type {string}
   * @memberof SetUserPasswordDto
   */
  password: string;
}
/**
 * 
 * @export
 * @interface SignInDto
 */
export interface SignInDto {
  /**
   * 
   * @type {string}
   * @memberof SignInDto
   */
  email: string;
  /**
   * 
   * @type {string}
   * @memberof SignInDto
   */
  password: string;
}
/**
 * 
 * @export
 * @interface SignInResponse
 */
export interface SignInResponse {
  /**
   * 
   * @type {string}
   * @memberof SignInResponse
   */
  accessToken: string;
  /**
   * 
   * @type {string}
   * @memberof SignInResponse
   */
  refreshToken: string;
  /**
   * 
   * @type {string}
   * @memberof SignInResponse
   */
  userId: string;
  /**
   * 
   * @type {string}
   * @memberof SignInResponse
   */
  userType: string;
}
/**
 * 
 * @export
 * @interface SpecialDistrictsCreateDto
 */
export interface SpecialDistrictsCreateDto {
  /**
   * 
   * @type {string}
   * @memberof SpecialDistrictsCreateDto
   */
  name: string;
  /**
   * 
   * @type {string}
   * @memberof SpecialDistrictsCreateDto
   */
  fipsCode: string;
  /**
   * 
   * @type {string}
   * @memberof SpecialDistrictsCreateDto
   */
  parentType: string;
  /**
   * 
   * @type {string}
   * @memberof SpecialDistrictsCreateDto
   */
  type: string;
  /**
   * 
   * @type {string}
   * @memberof SpecialDistrictsCreateDto
   */
  stateId: string;
  /**
   * 
   * @type {string}
   * @memberof SpecialDistrictsCreateDto
   */
  municipalityId: string;
  /**
   * 
   * @type {number}
   * @memberof SpecialDistrictsCreateDto
   */
  order: number;
}
/**
 * 
 * @export
 * @interface SpecialDistrictsCreateResponse
 */
export interface SpecialDistrictsCreateResponse {
  /**
   * 
   * @type {string}
   * @memberof SpecialDistrictsCreateResponse
   */
  id: string;
}
/**
 * 
 * @export
 * @interface StateCreateDto
 */
export interface StateCreateDto {
  /**
   * 
   * @type {string}
   * @memberof StateCreateDto
   */
  name: string;
  /**
   * 
   * @type {string}
   * @memberof StateCreateDto
   */
  code: string;
  /**
   * 
   * @type {number}
   * @memberof StateCreateDto
   */
  order: number;
}
/**
 * 
 * @export
 * @interface StateCreateResponse
 */
export interface StateCreateResponse {
  /**
   * 
   * @type {string}
   * @memberof StateCreateResponse
   */
  id: string;
}
/**
 * 
 * @export
 * @interface SystemAdminUserExistsError
 */
export interface SystemAdminUserExistsError {
  /**
   * 
   * @type {string}
   * @memberof SystemAdminUserExistsError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof SystemAdminUserExistsError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof SystemAdminUserExistsError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface TaxContactCreateDto
 */
export interface TaxContactCreateDto {
  /**
   * 
   * @type {string}
   * @memberof TaxContactCreateDto
   */
  name: string;
  /**
   * 
   * @type {string}
   * @memberof TaxContactCreateDto
   */
  title: string;
  /**
   * 
   * @type {string}
   * @memberof TaxContactCreateDto
   */
  email: string;
  /**
   * 
   * @type {string}
   * @memberof TaxContactCreateDto
   */
  phone: string;
}
/**
 * 
 * @export
 * @interface TaxInstallmentCreateDto
 */
export interface TaxInstallmentCreateDto {
  /**
   * 
   * @type {string}
   * @memberof TaxInstallmentCreateDto
   */
  dueDate: string;
  /**
   * 
   * @type {string}
   * @memberof TaxInstallmentCreateDto
   */
  delinquentCollector: string;
  /**
   * 
   * @type {string}
   * @memberof TaxInstallmentCreateDto
   */
  escrowCollector: string;
}
/**
 * 
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
  /**
   * 
   * @type {string}
   * @memberof UnauthorizedError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof UnauthorizedError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof UnauthorizedError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface UserCreateResponse
 */
export interface UserCreateResponse {
  /**
   * 
   * @type {string}
   * @memberof UserCreateResponse
   */
  id: string;
}
/**
 * 
 * @export
 * @interface UserExistsWithEmailError
 */
export interface UserExistsWithEmailError {
  /**
   * 
   * @type {string}
   * @memberof UserExistsWithEmailError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof UserExistsWithEmailError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof UserExistsWithEmailError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface UserIsNotEligibleForInvitationError
 */
export interface UserIsNotEligibleForInvitationError {
  /**
   * 
   * @type {string}
   * @memberof UserIsNotEligibleForInvitationError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof UserIsNotEligibleForInvitationError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof UserIsNotEligibleForInvitationError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface UserNotActiveError
 */
export interface UserNotActiveError {
  /**
   * 
   * @type {string}
   * @memberof UserNotActiveError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof UserNotActiveError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof UserNotActiveError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface UserNotFoundError
 */
export interface UserNotFoundError {
  /**
   * 
   * @type {string}
   * @memberof UserNotFoundError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof UserNotFoundError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof UserNotFoundError
   */
  errorStack: object;
}
/**
 * 
 * @export
 * @interface UserProfileDto
 */
export interface UserProfileDto {
  /**
   * 
   * @type {string}
   * @memberof UserProfileDto
   */
  firstName: string;
  /**
   * 
   * @type {string}
   * @memberof UserProfileDto
   */
  lastName: string;
  /**
   * 
   * @type {string}
   * @memberof UserProfileDto
   */
  email: string;
  /**
   * 
   * @type {string}
   * @memberof UserProfileDto
  /**
   * 
   * @type {string}
   * @memberof UserProfileDto
   */
  countryCode?: string;
  /**
   * 
   * @type {number}
   * @memberof UserProfileDto
   */
  phoneNumber?: number;
  /**
   * 
   * @type {boolean}
   * @memberof UserProfileDto
   */
  delinquentAlert: boolean;
  /**
   * 
   * @type {boolean}
   * @memberof UserProfileDto
   */
  escrowAlert: boolean;
  /**
   * 
   * @type {boolean}
   * @memberof UserProfileDto
   */
  isReadOnly: boolean;
  /**
   * 
   * @type {string}
   * @memberof UserProfileDto
   */
  userType: string;
}
/**
 * 
 * @export
 * @interface WrongPasswordError
 */
export interface WrongPasswordError {
  /**
   * 
   * @type {string}
   * @memberof WrongPasswordError
   */
  message: string;
  /**
   * 
   * @type {string}
   * @memberof WrongPasswordError
   */
  type: string;
  /**
   * 
   * @type {object}
   * @memberof WrongPasswordError
   */
  errorStack: object;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * 
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (changePasswordDto: ChangePasswordDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'changePasswordDto' is not null or undefined
      assertParamExists('changePassword', 'changePasswordDto', changePasswordDto)
      const localVarPath = `/v1/auth/change-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {ForgotPasswordDto} forgotPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgotPassword: async (forgotPasswordDto: ForgotPasswordDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'forgotPasswordDto' is not null or undefined
      assertParamExists('forgotPassword', 'forgotPasswordDto', forgotPasswordDto)
      const localVarPath = `/v1/auth/forgot-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (refreshTokenDto: RefreshTokenDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'refreshTokenDto' is not null or undefined
      assertParamExists('refreshToken', 'refreshTokenDto', refreshTokenDto)
      const localVarPath = `/v1/auth/refresh-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {SetUserPasswordDto} setUserPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserPassword: async (setUserPasswordDto: SetUserPasswordDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'setUserPasswordDto' is not null or undefined
      assertParamExists('setUserPassword', 'setUserPasswordDto', setUserPasswordDto)
      const localVarPath = `/v1/auth/set-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(setUserPasswordDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn: async (signInDto: SignInDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'signInDto' is not null or undefined
      assertParamExists('signIn', 'signInDto', signInDto)
      const localVarPath = `/v1/auth/sign-in`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(signInDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signOut: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('signOut', 'id', id)
      const localVarPath = `/v1/auth/sign-out/{id}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     * 
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(changePasswordDto: ChangePasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {ForgotPasswordDto} forgotPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async forgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(refreshTokenDto: RefreshTokenDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {SetUserPasswordDto} setUserPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserPassword(setUserPasswordDto: SetUserPasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserPassword(setUserPasswordDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signIn(signInDto: SignInDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(signInDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signOut(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signOut(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     * 
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<void> {
      return localVarFp.changePassword(changePasswordDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {ForgotPasswordDto} forgotPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): AxiosPromise<void> {
      return localVarFp.forgotPassword(forgotPasswordDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshTokenDto: RefreshTokenDto, options?: any): AxiosPromise<SignInResponse> {
      return localVarFp.refreshToken(refreshTokenDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {SetUserPasswordDto} setUserPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserPassword(setUserPasswordDto: SetUserPasswordDto, options?: any): AxiosPromise<void> {
      return localVarFp.setUserPassword(setUserPasswordDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn(signInDto: SignInDto, options?: any): AxiosPromise<SignInResponse> {
      return localVarFp.signIn(signInDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signOut(id: string, options?: any): AxiosPromise<void> {
      return localVarFp.signOut(id, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * 
   * @param {ChangePasswordDto} changePasswordDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public changePassword(changePasswordDto: ChangePasswordDto, options?: any) {
    return AuthApiFp(this.configuration).changePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {ForgotPasswordDto} forgotPasswordDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public forgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any) {
    return AuthApiFp(this.configuration).forgotPassword(forgotPasswordDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {RefreshTokenDto} refreshTokenDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public refreshToken(refreshTokenDto: RefreshTokenDto, options?: any) {
    return AuthApiFp(this.configuration).refreshToken(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {SetUserPasswordDto} setUserPasswordDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public setUserPassword(setUserPasswordDto: SetUserPasswordDto, options?: any) {
    return AuthApiFp(this.configuration).setUserPassword(setUserPasswordDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {SignInDto} signInDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signIn(signInDto: SignInDto, options?: any) {
    return AuthApiFp(this.configuration).signIn(signInDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {string} id 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signOut(id: string, options?: any) {
    return AuthApiFp(this.configuration).signOut(id, options).then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserRole: async (createRoleDto: CreateRoleDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'createRoleDto' is not null or undefined
      assertParamExists('createUserRole', 'createRoleDto', createRoleDto)
      const localVarPath = `/v1/role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createRoleDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserRoles: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)



      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration)
  return {
    /**
     * 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserRole(createRoleDto: CreateRoleDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserRole(createRoleDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserRoles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRoleListResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoles(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = RoleApiFp(configuration)
  return {
    /**
     * 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserRole(createRoleDto: CreateRoleDto, options?: any): AxiosPromise<CreateRoleResponse> {
      return localVarFp.createUserRole(createRoleDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserRoles(options?: any): AxiosPromise<GetRoleListResponse> {
      return localVarFp.getUserRoles(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
  /**
   * 
   * @param {CreateRoleDto} createRoleDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public createUserRole(createRoleDto: CreateRoleDto, options?: any) {
    return RoleApiFp(this.configuration).createUserRole(createRoleDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public getUserRoles(options?: any) {
    return RoleApiFp(this.configuration).getUserRoles(options).then((request) => request(this.axios, this.basePath));
  }
}


/**
 * SpecialDistrictsApi - axios parameter creator
 * @export
 */
export const SpecialDistrictsApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * 
     * @param {SpecialDistrictsCreateDto} specialDistrictsCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSpecialDistricts: async (specialDistrictsCreateDto: SpecialDistrictsCreateDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'specialDistrictsCreateDto' is not null or undefined
      assertParamExists('createSpecialDistricts', 'specialDistrictsCreateDto', specialDistrictsCreateDto)
      const localVarPath = `/v1/special-districts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(specialDistrictsCreateDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [type] 
     * @param {string} [parentType] 
     * @param {string} [stateId] 
     * @param {string} [municipalityId] 
     * @param {string} [fipsCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMunicipalities: async (skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, type?: string, parentType?: string, stateId?: string, municipalityId?: string, fipsCode?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/special-districts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      if (take !== undefined) {
        localVarQueryParameter['take'] = take;
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order;
      }

      if (sortby !== undefined) {
        localVarQueryParameter['sortby'] = sortby;
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (parentType !== undefined) {
        localVarQueryParameter['parentType'] = parentType;
      }

      if (stateId !== undefined) {
        localVarQueryParameter['stateId'] = stateId;
      }

      if (municipalityId !== undefined) {
        localVarQueryParameter['municipalityId'] = municipalityId;
      }

      if (fipsCode !== undefined) {
        localVarQueryParameter['fipsCode'] = fipsCode;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [type] 
     * @param {string} [parentType] 
     * @param {string} [stateId] 
     * @param {string} [municipalityId] 
     * @param {string} [fipsCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMunicipalitiesList: async (skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, type?: string, parentType?: string, stateId?: string, municipalityId?: string, fipsCode?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/special-districts/list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      if (take !== undefined) {
        localVarQueryParameter['take'] = take;
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order;
      }

      if (sortby !== undefined) {
        localVarQueryParameter['sortby'] = sortby;
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (parentType !== undefined) {
        localVarQueryParameter['parentType'] = parentType;
      }

      if (stateId !== undefined) {
        localVarQueryParameter['stateId'] = stateId;
      }

      if (municipalityId !== undefined) {
        localVarQueryParameter['municipalityId'] = municipalityId;
      }

      if (fipsCode !== undefined) {
        localVarQueryParameter['fipsCode'] = fipsCode;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * SpecialDistrictsApi - functional programming interface
 * @export
 */
export const SpecialDistrictsApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = SpecialDistrictsApiAxiosParamCreator(configuration)
  return {
    /**
     * 
     * @param {SpecialDistrictsCreateDto} specialDistrictsCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSpecialDistricts(specialDistrictsCreateDto: SpecialDistrictsCreateDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecialDistrictsCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSpecialDistricts(specialDistrictsCreateDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [type] 
     * @param {string} [parentType] 
     * @param {string} [stateId] 
     * @param {string} [municipalityId] 
     * @param {string} [fipsCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMunicipalities(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, type?: string, parentType?: string, stateId?: string, municipalityId?: string, fipsCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMunicipalities(skip, take, order, sortby, id, name, type, parentType, stateId, municipalityId, fipsCode, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [type] 
     * @param {string} [parentType] 
     * @param {string} [stateId] 
     * @param {string} [municipalityId] 
     * @param {string} [fipsCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMunicipalitiesList(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, type?: string, parentType?: string, stateId?: string, municipalityId?: string, fipsCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMunicipalitiesList(skip, take, order, sortby, id, name, type, parentType, stateId, municipalityId, fipsCode, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * SpecialDistrictsApi - factory interface
 * @export
 */
export const SpecialDistrictsApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SpecialDistrictsApiFp(configuration)
  return {
    /**
     * 
     * @param {SpecialDistrictsCreateDto} specialDistrictsCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSpecialDistricts(specialDistrictsCreateDto: SpecialDistrictsCreateDto, options?: any): AxiosPromise<SpecialDistrictsCreateResponse> {
      return localVarFp.createSpecialDistricts(specialDistrictsCreateDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [type] 
     * @param {string} [parentType] 
     * @param {string} [stateId] 
     * @param {string} [municipalityId] 
     * @param {string} [fipsCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMunicipalities(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, type?: string, parentType?: string, stateId?: string, municipalityId?: string, fipsCode?: string, options?: any): AxiosPromise<any> {
      return localVarFp.getMunicipalities(skip, take, order, sortby, id, name, type, parentType, stateId, municipalityId, fipsCode, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [type] 
     * @param {string} [parentType] 
     * @param {string} [stateId] 
     * @param {string} [municipalityId] 
     * @param {string} [fipsCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMunicipalitiesList(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, type?: string, parentType?: string, stateId?: string, municipalityId?: string, fipsCode?: string, options?: any): AxiosPromise<any> {
      return localVarFp.getMunicipalitiesList(skip, take, order, sortby, id, name, type, parentType, stateId, municipalityId, fipsCode, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * SpecialDistrictsApi - object-oriented interface
 * @export
 * @class SpecialDistrictsApi
 * @extends {BaseAPI}
 */
export class SpecialDistrictsApi extends BaseAPI {
  /**
   * 
   * @param {SpecialDistrictsCreateDto} specialDistrictsCreateDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecialDistrictsApi
   */
  public createSpecialDistricts(specialDistrictsCreateDto: SpecialDistrictsCreateDto, options?: any) {
    return SpecialDistrictsApiFp(this.configuration).createSpecialDistricts(specialDistrictsCreateDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {number} [skip] 
   * @param {number} [take] 
   * @param {'DESC' | 'ASC'} [order] 
   * @param {string} [sortby] 
   * @param {string} [id] 
   * @param {string} [name] 
   * @param {string} [type] 
   * @param {string} [parentType] 
   * @param {string} [stateId] 
   * @param {string} [municipalityId] 
   * @param {string} [fipsCode] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecialDistrictsApi
   */
  public getMunicipalities(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, type?: string, parentType?: string, stateId?: string, municipalityId?: string, fipsCode?: string, options?: any) {
    return SpecialDistrictsApiFp(this.configuration).getMunicipalities(skip, take, order, sortby, id, name, type, parentType, stateId, municipalityId, fipsCode, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {number} [skip] 
   * @param {number} [take] 
   * @param {'DESC' | 'ASC'} [order] 
   * @param {string} [sortby] 
   * @param {string} [id] 
   * @param {string} [name] 
   * @param {string} [type] 
   * @param {string} [parentType] 
   * @param {string} [stateId] 
   * @param {string} [municipalityId] 
   * @param {string} [fipsCode] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecialDistrictsApi
   */
  public getMunicipalitiesList(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, type?: string, parentType?: string, stateId?: string, municipalityId?: string, fipsCode?: string, options?: any) {
    return SpecialDistrictsApiFp(this.configuration).getMunicipalitiesList(skip, take, order, sortby, id, name, type, parentType, stateId, municipalityId, fipsCode, options).then((request) => request(this.axios, this.basePath));
  }
}


/**
 * StatesApi - axios parameter creator
 * @export
 */
export const StatesApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * 
     * @param {StateCreateDto} stateCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createState: async (stateCreateDto: StateCreateDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'stateCreateDto' is not null or undefined
      assertParamExists('createState', 'stateCreateDto', stateCreateDto)
      const localVarPath = `/v1/states`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(stateCreateDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStates: async (skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/states`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      if (take !== undefined) {
        localVarQueryParameter['take'] = take;
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order;
      }

      if (sortby !== undefined) {
        localVarQueryParameter['sortby'] = sortby;
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatesList: async (skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/states/list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      if (take !== undefined) {
        localVarQueryParameter['take'] = take;
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order;
      }

      if (sortby !== undefined) {
        localVarQueryParameter['sortby'] = sortby;
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * StatesApi - functional programming interface
 * @export
 */
export const StatesApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = StatesApiAxiosParamCreator(configuration)
  return {
    /**
     * 
     * @param {StateCreateDto} stateCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createState(stateCreateDto: StateCreateDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StateCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createState(stateCreateDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStates(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStates(skip, take, order, sortby, id, name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatesList(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatesList(skip, take, order, sortby, id, name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * StatesApi - factory interface
 * @export
 */
export const StatesApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = StatesApiFp(configuration)
  return {
    /**
     * 
     * @param {StateCreateDto} stateCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createState(stateCreateDto: StateCreateDto, options?: any): AxiosPromise<StateCreateResponse> {
      return localVarFp.createState(stateCreateDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStates(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, options?: any): AxiosPromise<any> {
      return localVarFp.getStates(skip, take, order, sortby, id, name, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatesList(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, options?: any): AxiosPromise<any> {
      return localVarFp.getStatesList(skip, take, order, sortby, id, name, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * StatesApi - object-oriented interface
 * @export
 * @class StatesApi
 * @extends {BaseAPI}
 */
export class StatesApi extends BaseAPI {
  /**
   * 
   * @param {StateCreateDto} stateCreateDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatesApi
   */
  public createState(stateCreateDto: StateCreateDto, options?: any) {
    return StatesApiFp(this.configuration).createState(stateCreateDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {number} [skip] 
   * @param {number} [take] 
   * @param {'DESC' | 'ASC'} [order] 
   * @param {string} [sortby] 
   * @param {string} [id] 
   * @param {string} [name] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatesApi
   */
  public getStates(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, options?: any) {
    return StatesApiFp(this.configuration).getStates(skip, take, order, sortby, id, name, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {number} [skip] 
   * @param {number} [take] 
   * @param {'DESC' | 'ASC'} [order] 
   * @param {string} [sortby] 
   * @param {string} [id] 
   * @param {string} [name] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatesApi
   */
  public getStatesList(skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, id?: string, name?: string, options?: any) {
    return StatesApiFp(this.configuration).getStatesList(skip, take, order, sortby, id, name, options).then((request) => request(this.axios, this.basePath));
  }
};
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * 
     * @param {UserProfileDto} userProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewUser: async (userProfileDto: UserProfileDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'userProfileDto' is not null or undefined
      assertParamExists('createNewUser', 'userProfileDto', userProfileDto)
      const localVarPath = `/v1/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userProfileDto, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [email] 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList: async (userType: 'organisationAdmin' | 'indexer' | 'verifier' | 'clarifier' | 'lender' | 'inveriTax', skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, email?: string, id?: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'userType' is not null or undefined
      console.log('userType', userType)
      assertParamExists('getUserList', 'userType', userType)
      const localVarPath = `/v1/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      if (take !== undefined) {
        localVarQueryParameter['take'] = take;
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order;
      }

      if (sortby !== undefined) {
        localVarQueryParameter['sortby'] = sortby;
      }

      if (userType !== undefined) {
        localVarQueryParameter['userType'] = userType;
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 
     * @param {string} id 
     * @param {string} firstName 
     * @param {string} lastName 
     * @param {string} email 
     * @param {string} roleId 
     * @param {string} delinquentAlert 
     * @param {string} escrowAlert 
     * @param {string} status 
     * @param {string} isReadOnly 
     * @param {string} userType 
     * @param {string} [countryCode] 
     * @param {number} [phoneNumber] 
     * @param {string} [removedPictureId] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (id: string, firstName: string, lastName: string, email: string, delinquentAlert: string, escrowAlert: string, status: string, isReadOnly: string, userType: string, countryCode?: string, phoneNumber?: number, removedPictureId?: string, file?: any, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateUser', 'id', id)
      // verify required parameter 'firstName' is not null or undefined
      assertParamExists('updateUser', 'firstName', firstName)
      // verify required parameter 'lastName' is not null or undefined
      assertParamExists('updateUser', 'lastName', lastName)
      // verify required parameter 'email' is not null or undefined
      assertParamExists('updateUser', 'email', email)
      // verify required parameter 'delinquentAlert' is not null or undefined
      assertParamExists('updateUser', 'delinquentAlert', delinquentAlert)
      // verify required parameter 'escrowAlert' is not null or undefined
      assertParamExists('updateUser', 'escrowAlert', escrowAlert)
      // verify required parameter 'status' is not null or undefined
      assertParamExists('updateUser', 'status', status)
      // verify required parameter 'isReadOnly' is not null or undefined
      assertParamExists('updateUser', 'isReadOnly', isReadOnly)
      // verify required parameter 'userType' is not null or undefined
      assertParamExists('updateUser', 'userType', userType)
      const localVarPath = `/v1/user/{id}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)


      if (firstName !== undefined) {
        localVarFormParams.append('firstName', firstName as any);
      }

      if (lastName !== undefined) {
        localVarFormParams.append('lastName', lastName as any);
      }

      if (email !== undefined) {
        localVarFormParams.append('email', email as any);
      }

      if (countryCode !== undefined) {
        localVarFormParams.append('countryCode', countryCode as any);
      }

      if (phoneNumber !== undefined) {
        localVarFormParams.append('phoneNumber', phoneNumber as any);
      }

      if (delinquentAlert !== undefined) {
        localVarFormParams.append('delinquentAlert', delinquentAlert as any);
      }

      if (escrowAlert !== undefined) {
        localVarFormParams.append('escrowAlert', escrowAlert as any);
      }

      if (status !== undefined) {
        localVarFormParams.append('status', status as any);
      }

      if (isReadOnly !== undefined) {
        localVarFormParams.append('isReadOnly', isReadOnly as any);
      }

      if (userType !== undefined) {
        localVarFormParams.append('userType', userType as any);
      }

      if (removedPictureId !== undefined) {
        localVarFormParams.append('removedPictureId', removedPictureId as any);
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }


      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     * 
     * @param {UserProfileDto} userProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNewUser(userProfileDto: UserProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createNewUser(userProfileDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {'organisationAdmin'|'indexer'|'verifier'|'clarifier'|'lender'|'inveriTax'} userType 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [email] 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserList(userType: 'organisationAdmin' | 'indexer' | 'verifier' | 'clarifier' | 'lender' | 'inveriTax', skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, email?: string, id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserListResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserList(userType, skip, take, order, sortby, email, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {string} id 
     * @param {string} firstName 
     * @param {string} lastName 
     * @param {string} email 
     * @param {string} roleId 
     * @param {string} delinquentAlert 
     * @param {string} escrowAlert 
     * @param {string} status 
     * @param {string} isReadOnly 
     * @param {string} userType 
     * @param {string} [countryCode] 
     * @param {number} [phoneNumber] 
     * @param {string} [removedPictureId] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(id: string, firstName: string, lastName: string, email: string, delinquentAlert: string, escrowAlert: string, status: string, isReadOnly: string, userType: string, countryCode?: string, phoneNumber?: number, removedPictureId?: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, firstName, lastName, email, delinquentAlert, escrowAlert, status, isReadOnly, userType, countryCode, phoneNumber, removedPictureId, file, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     * 
     * @param {UserProfileDto} userProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewUser(userProfileDto: UserProfileDto, options?: any): AxiosPromise<UserCreateResponse> {
      return localVarFp.createNewUser(userProfileDto, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {'organisationAdmin'|'indexer'|'verifier'|'clarifier'|'lender'|'inveriTax'} userType 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {'DESC' | 'ASC'} [order] 
     * @param {string} [sortby] 
     * @param {string} [email] 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList(userType: 'organisationAdmin' | 'indexer' | 'verifier' | 'clarifier' | 'lender' | 'inveriTax', skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, email?: string, id?: string, options?: any): AxiosPromise<GetUserListResponse> {
      return localVarFp.getUserList(userType, skip, take, order, sortby, email, id, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {string} id 
     * @param {string} firstName 
     * @param {string} lastName 
     * @param {string} email 
     * @param {string} roleId 
     * @param {string} delinquentAlert 
     * @param {string} escrowAlert 
     * @param {string} status 
     * @param {string} isReadOnly 
     * @param {string} userType 
     * @param {string} [countryCode] 
     * @param {number} [phoneNumber] 
     * @param {string} [removedPictureId] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(id: string, firstName: string, lastName: string, email: string, delinquentAlert: string, escrowAlert: string, status: string, isReadOnly: string, userType: string, countryCode?: string, phoneNumber?: number, removedPictureId?: string, file?: any, options?: any): AxiosPromise<void> {
      return localVarFp.updateUser(id, firstName, lastName, email, delinquentAlert, escrowAlert, status, isReadOnly, userType, countryCode, phoneNumber, removedPictureId, file, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * 
   * @param {UserProfileDto} userProfileDto 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public createNewUser(userProfileDto: UserProfileDto, options?: any) {
    return UserApiFp(this.configuration).createNewUser(userProfileDto, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {'organisationAdmin'|'indexer'|'verifier'|'clarifier'|'lender'|'inveriTax'} userType 
   * @param {number} [skip] 
   * @param {number} [take] 
   * @param {'DESC' | 'ASC'} [order] 
   * @param {string} [sortby] 
   * @param {string} [email] 
   * @param {string} [id] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserList(userType: 'organisationAdmin' | 'indexer' | 'verifier' | 'clarifier' | 'lender' | 'inveriTax', skip?: number, take?: number, order?: 'DESC' | 'ASC', sortby?: string, email?: string, id?: string, options?: any) {
    return UserApiFp(this.configuration).getUserList(userType, skip, take, order, sortby, email, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * 
   * @param {string} id 
   * @param {string} firstName 
   * @param {string} lastName 
   * @param {string} email 
   * @param {string} roleId 
   * @param {string} delinquentAlert 
   * @param {string} escrowAlert 
   * @param {string} status 
   * @param {string} isReadOnly 
   * @param {string} userType 
   * @param {string} [countryCode] 
   * @param {number} [phoneNumber] 
   * @param {string} [removedPictureId] 
   * @param {any} [file] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateUser(id: string, firstName: string, lastName: string, email: string, delinquentAlert: string, escrowAlert: string, status: string, isReadOnly: string, userType: string, countryCode?: string, phoneNumber?: number, removedPictureId?: string, file?: any, options?: any) {
    return UserApiFp(this.configuration).updateUser(id, firstName, lastName, email, delinquentAlert, escrowAlert, status, isReadOnly, userType, countryCode, phoneNumber, removedPictureId, file, options).then((request) => request(this.axios, this.basePath));
  }
}


